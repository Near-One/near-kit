<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>near-kit</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./theme/catppuccin.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "latte";
            const default_dark_theme = "mocha";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">near-kit</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started-with-near-kit"><a class="header" href="#getting-started-with-near-kit">Getting Started with near-kit</a></h1>
<p>Welcome to <code>near-kit</code>! This guide will walk you through the initial setup and your first real transaction, explaining each step along the way. By the end, you'll have a solid understanding of how to interact with the NEAR blockchain using this library.</p>
<h2 id="philosophy"><a class="header" href="#philosophy">Philosophy</a></h2>
<p><code>near-kit</code> is designed to be simple and intuitive. If you know how to use a <code>fetch</code> API, you'll feel right at home. We handle the complex parts of blockchain interaction so you can focus on building your application.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ol>
<li><strong>Node.js or Bun:</strong> This library works in both server-side and browser environments. For this guide, we'll use a Node.js/Bun environment.</li>
<li><strong>A NEAR Testnet Account:</strong> You'll need an account to sign and send transactions. If you don't have one, you can create one at <a href="https://wallet.testnet.near.org/">NEAR Wallets (Testnet)</a>.</li>
<li><strong>A Private Key:</strong> To sign transactions, you need a private key. After creating a testnet account, you can find your key in your browser's local storage or in the <code>~/.near-credentials/</code> directory if you've used <code>near-cli</code>.</li>
</ol>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>First, add <code>near-kit</code> to your project:</p>
<pre><code class="language-bash">npm install near-kit
</code></pre>
<h2 id="your-first-script"><a class="header" href="#your-first-script">Your First Script</a></h2>
<p>Let's write a script that connects to the testnet, reads data from a contract, and then sends a transaction to it.</p>
<p>Create a file named <code>index.ts</code>:</p>
<pre><code class="language-typescript">import { InMemoryKeyStore, Near, parseKey } from "near-kit"

// --- 1. Set up your credentials ---
// NOTE: Do not hardcode private keys in production! Use environment variables.
const YOUR_ACCOUNT_ID = "your-account.testnet"
const YOUR_PRIVATE_KEY = "ed25519:...." // Your testnet private key

// Optional: if you want `near.transaction(YOUR_ACCOUNT_ID)` to work without
// passing a signerId every time, preload the key into a keyStore:
const keyStore = new InMemoryKeyStore()
const keyPair = parseKey(YOUR_PRIVATE_KEY)
await keyStore.add(YOUR_ACCOUNT_ID, keyPair)

async function main() {
  if (YOUR_ACCOUNT_ID === "your-account.testnet") {
    console.warn(
      "Please replace YOUR_ACCOUNT_ID and YOUR_PRIVATE_KEY in this example."
    )
    return
  }

  // --- 2. Initialize the client ---
  // Connect to the testnet and provide your private key for signing.
  const near = new Near({
    network: "testnet",
    keyStore,
    defaultSignerId: YOUR_ACCOUNT_ID,
  })

  console.log(`Initialized client for account [${YOUR_ACCOUNT_ID}]`)

  // --- 3. View a contract (read-only, no cost) ---
  // Let's check the messages on the guest book contract.
  const messages = await near.view(
    "guestbook.near-examples.testnet",
    "get_messages",
    {}
  )
  console.log("Latest messages on the guest book:", messages)

  // --- 4. Send a transaction (write) ---
  // Now, let's add our own message to the guest book.
  console.log("Sending a transaction to add a message...")

  const result = await near
    .transaction(YOUR_ACCOUNT_ID)
    .functionCall(
      "guestbook.near-examples.testnet",
      "add_message",
      { text: "Hello from near-kit!" },
      { gas: "30 Tgas" } // Attach 30 Tgas to the call
    )
    .send() // Signs and sends the transaction

  console.log("✅ Transaction sent successfully!")
  console.log("Transaction Hash:", result.transaction.hash)
}

main().catch(console.error)
</code></pre>
<h3 id="running-the-script"><a class="header" href="#running-the-script">Running the Script</a></h3>
<p>Replace the placeholder credentials and run the file:</p>
<pre><code class="language-bash">bun run index.ts
</code></pre>
<p>You should see output confirming the client initialization, the number of messages, and finally the success message with your transaction hash. Congratulations, you've just interacted with the NEAR blockchain!</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<p>Now that you've sent your first transaction, let's dive into the core concepts that make <code>near-kit</code> powerful and easy to use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>Understanding a few core concepts will help you get the most out of <code>near-kit</code>.</p>
<h2 id="the-near-class"><a class="header" href="#the-near-class">The <code>Near</code> Class</a></h2>
<p>The <code>Near</code> class is the main entry point for all interactions. You initialize it once with your configuration.</p>
<pre><code class="language-typescript">import { Near } from "near-kit"

// Connect to testnet with a private key
const near = new Near({
  network: "testnet",
  privateKey: "ed25519:...",
})
</code></pre>
<p>The constructor is flexible and can be configured for different networks, key management strategies, and environments.</p>
<h2 id="view-vs-call-the-two-types-of-interaction"><a class="header" href="#view-vs-call-the-two-types-of-interaction">View vs. Call: The Two Types of Interaction</a></h2>
<p>On any blockchain, there are two fundamental types of operations: reading data and writing data. <code>near-kit</code> makes this distinction clear with <code>view()</code> and <code>call()</code>/<code>transaction()</code>.</p>
<h3 id="nearview---reading-data"><a class="header" href="#nearview---reading-data"><code>near.view()</code> - Reading Data</a></h3>
<ul>
<li><strong>Read-only:</strong> It cannot change anything on the blockchain.</li>
<li><strong>Free:</strong> It costs no gas.</li>
<li><strong>No Signature:</strong> It doesn't require a private key.</li>
<li><strong>Synchronous:</strong> It returns the data you asked for directly.</li>
</ul>
<p>Use <code>near.view()</code> whenever you want to query a contract's state.</p>
<pre><code class="language-typescript">const messages = await near.view(
  "guestbook.near-examples.testnet",
  "get_messages",
  {}
)
</code></pre>
<h3 id="neartransaction---writing-data"><a class="header" href="#neartransaction---writing-data"><code>near.transaction()</code> - Writing Data</a></h3>
<ul>
<li><strong>State-Changing:</strong> This is for any action that modifies the blockchain (sending tokens, calling a change method, etc.).</li>
<li><strong>Costs Gas:</strong> It requires the signer to pay a transaction fee.</li>
<li><strong>Requires Signature:</strong> It must be signed by a private key or a wallet.</li>
<li><strong>Asynchronous:</strong> It returns a transaction receipt, and the final result happens on-chain.</li>
</ul>
<p>Use <code>near.transaction()</code> for any operation that writes data.</p>
<pre><code class="language-typescript">const result = await near
  .transaction("alice.testnet")
  .functionCall("guestbook.near-examples.testnet", "add_message", {
    text: "Hello!",
  })
  .send()
</code></pre>
<h2 id="human-readable-units"><a class="header" href="#human-readable-units">Human-Readable Units</a></h2>
<p>One of the biggest sources of bugs in blockchain development is unit conversion. NEAR's base unit is the <strong>yoctoNEAR</strong> (10<sup>-24</sup> NEAR), which often involves counting lots of zeros.</p>
<p><code>near-kit</code> solves this by letting you use human-readable strings. The library handles the conversion for you.</p>
<h3 id="amounts"><a class="header" href="#amounts">Amounts</a></h3>
<ul>
<li><strong>Use <code>"10.5 NEAR"</code> for token amounts.</strong></li>
<li><strong>Use <code>"1 yocto"</code> for the smallest unit, often required for storage deposits.</strong></li>
</ul>
<pre><code class="language-typescript">// Send 10.5 NEAR
await near.transaction(sender).transfer(receiver, "10.5 NEAR").send()

// Call a function and attach exactly 1 yoctoNEAR
await near
  .transaction(sender)
  .functionCall(
    contract,
    "method",
    {},
    {
      attachedDeposit: "1 yocto",
    }
  )
  .send()
</code></pre>
<h3 id="gas"><a class="header" href="#gas">Gas</a></h3>
<ul>
<li><strong>Use <code>"30 Tgas"</code> for gas amounts.</strong> (Tgas = Tera-gas = 10<sup>12</sup> gas units).</li>
</ul>
<pre><code class="language-typescript">await near
  .transaction(sender)
  .functionCall(
    contract,
    "method",
    {},
    {
      gas: "50 Tgas", // Attach 50 Tgas
    }
  )
  .send()
</code></pre>
<p>This approach makes your code more readable and less error-prone.</p>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What's Next?</a></h2>
<p>Now that you understand the basic building blocks, let's take a closer look at how to construct complex transactions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-transactions"><a class="header" href="#making-transactions">Making Transactions</a></h1>
<p>The <code>near.transaction()</code> builder is the heart of <code>near-kit</code>. It provides a fluent, chainable API to construct and send transactions with one or more actions.</p>
<h2 id="the-fluent-api"><a class="header" href="#the-fluent-api">The Fluent API</a></h2>
<p>You start a transaction by specifying the <strong>signer account ID</strong>—the account that will sign the transaction and pay for the gas fees.</p>
<pre><code class="language-typescript">near.transaction("signer.near") // 'signer.near' pays for this transaction
</code></pre>
<p>From there, you chain one or more <strong>actions</strong>.</p>
<h3 id="atomic-by-nature"><a class="header" href="#atomic-by-nature">Atomic by Nature</a></h3>
<p>All actions added to a single transaction are <strong>atomic</strong>. This is a critical concept: they either <strong>all succeed</strong> or <strong>all fail</strong> together. If any single action fails, the entire transaction is reverted, and no state is changed.</p>
<h2 id="common-actions"><a class="header" href="#common-actions">Common Actions</a></h2>
<p>Here are the most common actions you can add to a transaction.</p>
<h3 id="transfer"><a class="header" href="#transfer"><code>transfer()</code></a></h3>
<p>Send NEAR tokens from the signer to a receiver.</p>
<pre><code class="language-typescript">await near
  .transaction("alice.near")
  .transfer("bob.near", "10.5 NEAR") // Alice sends 10.5 NEAR to Bob
  .send()
</code></pre>
<h3 id="functioncall"><a class="header" href="#functioncall"><code>functionCall()</code></a></h3>
<p>Call a method on a smart contract.</p>
<ul>
<li><code>contractId</code>: The contract account to call.</li>
<li><code>methodName</code>: The method to execute.</li>
<li><code>args</code>: A JSON-serializable object of arguments.</li>
<li><code>options</code>: Optional <code>gas</code> and <code>attachedDeposit</code>.</li>
</ul>
<pre><code class="language-typescript">await near
  .transaction("alice.near")
  .functionCall(
    "market.near",
    "buy_nft",
    { token_id: "token-1" },
    {
      gas: "50 Tgas",
      attachedDeposit: "10 NEAR", // Alice attaches 10 NEAR to the call
    }
  )
  .send()
</code></pre>
<h3 id="createaccount"><a class="header" href="#createaccount"><code>createAccount()</code></a></h3>
<p>Create a new NEAR account. This new account ID becomes the receiver of subsequent actions in the same transaction.</p>
<pre><code class="language-typescript">await near.transaction("alice.near").createAccount("new-account.near").send()
</code></pre>
<h3 id="deploycontract"><a class="header" href="#deploycontract"><code>deployContract()</code></a></h3>
<p>Deploy Wasm bytecode to an account, turning it into a smart contract.</p>
<pre><code class="language-typescript">import { readFileSync } from "fs"

const contractWasm = readFileSync("path/to/contract.wasm")

await near
  .transaction("my-contract.near")
  .deployContract("my-contract.near", contractWasm)
  .send()
</code></pre>
<h3 id="addkey"><a class="header" href="#addkey"><code>addKey()</code></a></h3>
<p>Add a new access key to an account.</p>
<ul>
<li><strong>Full Access Key:</strong> Can sign any transaction on behalf of the account.</li>
<li><strong>Function Call Key:</strong> Limited to calling specific methods on a specific contract.</li>
</ul>
<pre><code class="language-typescript">import { generateKey } from "near-kit"

const newKey = generateKey()

// Add a full access key
await near
  .transaction("alice.near")
  .addKey(newKey.publicKey.toString(), { type: "fullAccess" })
  .send()

// Add a limited function call key
await near
  .transaction("alice.near")
  .addKey(newKey.publicKey.toString(), {
    type: "functionCall",
    receiverId: "some-contract.near", // The contract this key can call
    methodNames: ["some_method"], // The specific methods allowed
    allowance: "0.25 NEAR", // Optional allowance for gas/deposits
  })
  .send()
</code></pre>
<h2 id="chaining-multiple-actions"><a class="header" href="#chaining-multiple-actions">Chaining Multiple Actions</a></h2>
<p>The real power comes from combining actions. This example creates a new sub-account, transfers funds to it, and adds a full access key, all in one atomic transaction.</p>
<pre><code class="language-typescript">const newAccount = `sub.${YOUR_ACCOUNT_ID}`
const newKey = generateKey()

const result = await near
  .transaction(YOUR_ACCOUNT_ID)
  .createAccount(newAccount)
  .transfer(newAccount, "5 NEAR")
  .addKey(newKey.publicKey.toString(), { type: "fullAccess" })
  .send()

console.log(`${newAccount} created successfully!`)
</code></pre>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What's Next?</a></h2>
<p>Now that you can build any transaction, let's see how <code>near-kit</code> can make your contract interactions safer and more developer-friendly with TypeScript.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-safe-contracts"><a class="header" href="#type-safe-contracts">Type-Safe Contracts</a></h1>
<p>While <code>near.view()</code> and <code>near.call()</code> are powerful, they are not type-safe out of the box. You can pass any method name or arguments, and TypeScript won't catch mistakes.</p>
<p><code>near-kit</code> solves this with a <code>near.contract&lt;T&gt;()</code> interface that gives you full type safety and IDE autocompletion for your contract interactions.</p>
<h2 id="the-problem-no-type-safety"><a class="header" href="#the-problem-no-type-safety">The Problem: No Type Safety</a></h2>
<p>Consider this standard <code>near.call()</code>:</p>
<pre><code class="language-typescript">// What if the method is misspelled? 'nft_tranfer' instead of 'nft_transfer'?
// What if 'token_id' should be a number instead of a string?
// TypeScript can't help you here.
await near.call("nft.near", "nft_tranfer", {
  reciever_id: "bob.near", // Another typo!
  token_id: "token-1",
})
</code></pre>
<p>These errors will only be discovered at runtime, which is slow and frustrating.</p>
<h2 id="the-solution-nearcontractt"><a class="header" href="#the-solution-nearcontractt">The Solution: <code>near.contract&lt;T&gt;()</code></a></h2>
<p>With <code>near.contract()</code>, you define a TypeScript <code>interface</code> that describes your contract's methods. <code>near-kit</code> then uses this interface to create a fully typed contract object.</p>
<h3 id="step-1-define-your-contract-interface"><a class="header" href="#step-1-define-your-contract-interface">Step 1: Define Your Contract Interface</a></h3>
<p>Create an interface that matches the methods on your smart contract. Separate them into <code>view</code> (read-only) and <code>call</code> (change) methods.</p>
<pre><code class="language-typescript">// Define the structure of your contract's public methods
interface NftContract {
  view: {
    // view methods return a Promise with the expected data type
    nft_token(args: {
      token_id: string
    }): Promise&lt;{ owner_id: string; metadata: object }&gt;
  }
  call: {
    // call methods usually return a Promise&lt;void&gt; or the final transaction result
    nft_transfer(args: { receiver_id: string; token_id: string }): Promise&lt;void&gt;
  }
}
</code></pre>
<h3 id="step-2-create-a-typed-contract-instance"><a class="header" href="#step-2-create-a-typed-contract-instance">Step 2: Create a Typed Contract Instance</a></h3>
<p>Use <code>near.contract&lt;T&gt;()</code> with your interface and the contract's account ID.</p>
<pre><code class="language-typescript">const contract = near.contract&lt;NftContract&gt;("paras-token-v2.testnet")
</code></pre>
<h3 id="step-3-enjoy-type-safety-and-autocompletion"><a class="header" href="#step-3-enjoy-type-safety-and-autocompletion">Step 3: Enjoy Type Safety and Autocompletion!</a></h3>
<p>Now, when you use the <code>contract</code> object, your IDE will provide autocompletion, and TypeScript will enforce correct method names and argument types.</p>
<pre><code class="language-typescript">// ✅ Correct and autocompleted!
const nft = await contract.view.nft_token({ token_id: "2318:2" })
console.log("Owner:", nft.owner_id)

// ❌ Examples of invalid code that TypeScript will reject:
//
// await contract.call.nft_tranfer({ ... })
//
// await contract.call.nft_transfer({
//   reciever_id: "bob.near",
//   token_id: "2318:2",
// })
</code></pre>
<p>This simple pattern catches bugs before you even run your code, dramatically speeding up development and increasing the reliability of your application.</p>
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What's Next?</a></h2>
<p>So far, we've focused on server-side interactions. Let's explore how to use <code>near-kit</code> in the browser to interact with user wallets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="browser-wallets"><a class="header" href="#browser-wallets">Browser Wallets</a></h1>
<p>While server-side applications use private keys, decentralized applications (dApps) in the browser need to interact with a user's wallet. <code>near-kit</code> provides simple adapters to integrate with the most popular wallet connection libraries.</p>
<h2 id="the-universal-code-pattern"><a class="header" href="#the-universal-code-pattern">The Universal Code Pattern</a></h2>
<p>A key design principle of <code>near-kit</code> is that your <strong>business logic should not change</strong> whether you are running on a server or in a browser. The way you build a transaction is always the same.</p>
<pre><code class="language-typescript">// This function works anywhere!
async function addGuestbookMessage(
  near: Near,
  signerId: string,
  message: string
) {
  return await near
    .transaction(signerId)
    .functionCall(
      "guestbook.near-examples.testnet",
      "add_message",
      { text: message },
      { gas: "30 Tgas" }
    )
    .send()
}
</code></pre>
<p>The only difference is how you initialize the <code>Near</code> class.</p>
<ul>
<li><strong>Server:</strong> <code>new Near({ privateKey: '...' })</code></li>
<li><strong>Browser:</strong> <code>new Near({ wallet: fromWalletAdapter(...) })</code></li>
</ul>
<h2 id="integrating-with-wallet-selector"><a class="header" href="#integrating-with-wallet-selector">Integrating with Wallet Selector</a></h2>
<p><code>@near-wallet-selector</code> is a popular library for providing a modal that lets users choose from many different wallets.</p>
<h3 id="step-1-install-dependencies"><a class="header" href="#step-1-install-dependencies">Step 1: Install Dependencies</a></h3>
<pre><code class="language-bash">npm install near-kit @near-wallet-selector/core @near-wallet-selector/modal-ui @near-wallet-selector/my-near-wallet
</code></pre>
<h3 id="step-2-set-up-wallet-selector-and-near-kit"><a class="header" href="#step-2-set-up-wallet-selector-and-near-kit">Step 2: Set up Wallet Selector and <code>near-kit</code></a></h3>
<p>The <code>fromWalletSelector()</code> adapter makes integration seamless.</p>
<pre><code class="language-typescript">import { Near, fromWalletSelector } from "near-kit"
import { setupWalletSelector } from "@near-wallet-selector/core"
import { setupModal } from "@near-wallet-selector/modal-ui"
import { setupMyNearWallet } from "@near-wallet-selector/my-near-wallet"

// 1. Set up Wallet Selector
const selector = await setupWalletSelector({
  network: "testnet",
  modules: [setupMyNearWallet()],
})

// 2. Set up the modal UI
const modal = setupModal(selector, {
  contractId: "guest-book.testnet",
})

// Show the modal when the user clicks a "Connect" button
// modal.show();

// 3. Listen for sign-in and initialize near-kit
selector.store.observable.subscribe(async (state) =&gt; {
  if (state.accounts.length &gt; 0) {
    const wallet = await selector.wallet()
    const accountId = state.accounts[0]?.accountId

    if (!accountId) return

    // 4. Create a Near instance using the wallet adapter
    const near = new Near({
      network: "testnet",
      wallet: fromWalletSelector(wallet),
    })

    // 5. Now use the universal code pattern!
    await addGuestbookMessage(near, accountId, "Hello from my dApp!")
  }
})
</code></pre>
<p>When <code>addGuestbookMessage</code> is called, <code>near-kit</code> will automatically delegate the signing request to the user's connected wallet, prompting them to approve the transaction.</p>
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What's Next?</a></h2>
<p>A critical part of development is testing. Learn how to use the built-in Sandbox for fast, reliable, and free testing.</p>
<ul>
<li><strong>Next Guide:</strong> <a href="./06-testing-with-sandbox.html">06 - Testing with Sandbox</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-with-sandbox"><a class="header" href="#testing-with-sandbox">Testing with Sandbox</a></h1>
<p>Testing blockchain applications can be slow and expensive. You have to wait for transaction finality on a public testnet, and managing test accounts and state is difficult.</p>
<p><code>near-kit</code> solves this with a built-in <strong>Sandbox</strong>: a complete, local NEAR blockchain that runs on your machine.</p>
<h2 id="benefits-of-sandbox"><a class="header" href="#benefits-of-sandbox">Benefits of Sandbox</a></h2>
<ul>
<li><strong>Instant Finality:</strong> Transactions are confirmed instantly.</li>
<li><strong>Free:</strong> All operations are free. No need for a testnet faucet.</li>
<li><strong>Isolated:</strong> Your tests run in a clean, predictable environment without interference from other developers.</li>
<li><strong>Easy Setup:</strong> Start and stop the entire blockchain with just two lines of code.</li>
</ul>
<h2 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h2>
<p>The Sandbox runs a real NEAR node, which requires a high file descriptor limit.</p>
<ul>
<li><strong>Check your limit:</strong> <code>ulimit -n</code></li>
<li><strong>If the value is less than 65535, you must increase it.</strong></li>
</ul>
<p>Please see the <a href="../src/sandbox/README.html">Sandbox Setup Instructions</a> for platform-specific commands (macOS, Linux, Docker).</p>
<h2 id="usage-with-a-test-framework"><a class="header" href="#usage-with-a-test-framework">Usage with a Test Framework</a></h2>
<p>The Sandbox is perfect for integration tests. Here’s how to use it with <code>bun:test</code>, but the pattern works for Jest, Vitest, or any other framework.</p>
<p>Create a test file like <code>tests/integration.test.ts</code>:</p>
<pre><code class="language-typescript">import { Near } from "near-kit"
import { Sandbox } from "near-kit/sandbox"
import { beforeAll, afterAll, test, expect } from "bun:test"

// These tests can take a moment to initialize the sandbox
describe("My Application Tests", () =&gt; {
  let sandbox: Sandbox
  let near: Near

  // 1. Start the Sandbox before all tests
  beforeAll(async () =&gt; {
    sandbox = await Sandbox.start()
    near = new Near({ network: sandbox })
    console.log("Sandbox started for tests.")
  }, 120000) // Increase timeout for the first-time binary download

  // 2. Stop the Sandbox after all tests
  afterAll(async () =&gt; {
    if (sandbox) {
      await sandbox.stop()
      console.log("Sandbox stopped.")
    }
  })

  // 3. Write your tests!
  test("should create an account and transfer funds", async () =&gt; {
    const newAccountId = `test-account.${sandbox.rootAccount.id}`

    // The root account is available via sandbox.rootAccount
    // Its key is automatically loaded into the Near instance.
    const result = await near
      .transaction(sandbox.rootAccount.id)
      .createAccount(newAccountId)
      .transfer(newAccountId, "100 NEAR")
      .send()

    expect(result.final_execution_status).toContain("EXECUTED")

    // Verify the result
    const balance = await near.getBalance(newAccountId)
    expect(balance).toBe("100.00") // getBalance returns formatted NEAR
  })

  test("should call a smart contract", async () =&gt; {
    // In a real test, you would first deploy your contract here.
    // For this example, we'll assume a contract is at 'my-contract.test.near'
    // This is just a placeholder to show the pattern.
    // await near.transaction(sandbox.rootAccount.id)
    //   .functionCall('my-contract.test.near', 'some_method', {})
    //   .send();
  })
})
</code></pre>
<h3 id="the-sandbox-object"><a class="header" href="#the-sandbox-object">The <code>sandbox</code> Object</a></h3>
<p>The <code>Sandbox.start()</code> method returns an object with everything you need:</p>
<ul>
<li><code>sandbox.rpcUrl</code>: The RPC endpoint for this sandbox instance.</li>
<li><code>sandbox.networkId</code>: Always <code>'localnet'</code>.</li>
<li><code>sandbox.rootAccount.id</code>: The ID of the pre-funded root account (e.g., <code>test.near</code>).</li>
<li><code>sandbox.rootAccount.secretKey</code>: The private key for the root account.</li>
</ul>
<p>When you pass the <code>sandbox</code> object to <code>new Near()</code>, <code>near-kit</code> automatically configures the RPC connection and loads the root account's key into an in-memory keystore, making it ready to sign transactions immediately.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-errors"><a class="header" href="#handling-errors">Handling Errors</a></h1>
<p>When you're interacting with a decentralized network, a lot can go wrong: a user might not have enough funds, a contract might have a bug, or the network itself could be slow. <code>near-kit</code> provides a set of typed errors to help you handle these cases gracefully.</p>
<h2 id="the-trycatch-pattern"><a class="header" href="#the-trycatch-pattern">The <code>try...catch</code> Pattern</a></h2>
<p>All <code>near-kit</code> errors extend the base JavaScript <code>Error</code>, so you can use a standard <code>try...catch</code> block. The real power comes from using <code>instanceof</code> to check for specific error types.</p>
<pre><code class="language-typescript">import {
  Near,
  FunctionCallError,
  AccountDoesNotExistError,
  NetworkError,
} from "near-kit"

// Replace with your real testnet private key
const near = new Near({
  network: "testnet",
  privateKey: "ed25519:...", // Your testnet private key
})

try {
  const result = await near
    .transaction("signer.testnet")
    .functionCall("some-contract.testnet", "some_method", {})
    .send()
} catch (error) {
  // Check the error's type
  if (error instanceof FunctionCallError) {
    // The smart contract itself panicked.
    console.error(`Contract Error in ${error.contractId}:`)
    console.error(`- Method: ${error.methodName}`)
    console.error(`- Panic Message: ${error.panic}`)
    console.error(`- Logs:`, error.logs)
  } else if (error instanceof AccountDoesNotExistError) {
    // The target account doesn't exist.
    console.error(`Account ${error.accountId} does not exist.`)
  } else if (error instanceof NetworkError) {
    // The RPC request failed.
    console.error(`Network Error: ${error.message}`)
    if (error.retryable) {
      console.log("This error is retryable. Please try again later.")
    }
  } else if (error instanceof Error) {
    // Handle other potential errors.
    console.error("An unknown error occurred:", error.message)
  } else {
    console.error("An unknown non-Error was thrown:", error)
  }
}
</code></pre>
<h2 id="most-common-errors"><a class="header" href="#most-common-errors">Most Common Errors</a></h2>
<ul>
<li>
<p><strong><code>FunctionCallError</code></strong>: The most common error. It means your transaction was valid, but the smart contract code failed (panicked) during execution.</p>
<ul>
<li><code>error.panic</code>: Contains the actual panic message from the contract (e.g., "ERR_NOT_ENOUGH_FUNDS"). This is extremely useful for debugging.</li>
<li><code>error.logs</code>: Contains any log messages the contract emitted before it failed.</li>
</ul>
</li>
<li>
<p><strong><code>InvalidTransactionError</code></strong>: The transaction itself was rejected by the network before it could even get to the contract. This often happens due to:</p>
<ul>
<li>An invalid account ID (<code>AccountAlreadyExists</code>).</li>
<li>Trying to use an access key with insufficient permissions.</li>
<li>An invalid nonce (often handled automatically by <code>near-kit</code>).</li>
</ul>
</li>
<li>
<p><strong><code>AccountDoesNotExistError</code></strong>: You tried to interact with an account that hasn't been created yet.</p>
</li>
<li>
<p><strong><code>NetworkError</code></strong>: The RPC node failed to respond. This can happen if the node is down or your connection is interrupted.</p>
<ul>
<li><code>error.retryable</code>: A boolean indicating if you can safely retry the same operation.</li>
</ul>
</li>
</ul>
<p>By handling these typed errors, you can build a much more robust and user-friendly application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-near-api-js"><a class="header" href="#migrating-from-near-api-js">Migrating from near-api-js</a></h1>
<p>If you're coming from <code>near-api-js</code>, you'll find that <code>near-kit</code> accomplishes the same tasks with a more modern and streamlined API. This guide highlights the key differences to help you migrate quickly.</p>
<h2 id="philosophy-shift"><a class="header" href="#philosophy-shift">Philosophy Shift</a></h2>
<ul>
<li><strong><code>near-kit</code></strong>: Focuses on a simple, <code>fetch</code>-like developer experience with human-readable units and a fluent transaction builder.</li>
<li><strong><code>near-api-js</code></strong>: A more verbose, object-oriented library that often requires manual unit conversion.</li>
</ul>
<h2 id="side-by-side-comparison"><a class="header" href="#side-by-side-comparison">Side-by-Side Comparison</a></h2>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p><strong>near-api-js:</strong></p>
<pre><code class="language-typescript">const { connect, keyStores, KeyPair } = require("near-api-js")

const keyStore = new keyStores.InMemoryKeyStore()
const keyPair = KeyPair.fromString("ed25519:...")
await keyStore.setKey("testnet", "alice.testnet", keyPair)

const config = {
  networkId: "testnet",
  keyStore,
  nodeUrl: "https://rpc.testnet.near.org",
  walletUrl: "https://wallet.testnet.near.org",
}
const near = await connect(config)
const account = await near.account("alice.testnet")
</code></pre>
<p><strong>near-kit:</strong></p>
<pre><code class="language-typescript">import { Near } from "near-kit"

const near = new Near({
  network: "testnet",
  privateKey: "ed25519:...",
})
</code></pre>
<h3 id="viewing-a-contract"><a class="header" href="#viewing-a-contract">Viewing a Contract</a></h3>
<p><strong>near-api-js:</strong></p>
<pre><code class="language-typescript">const response = await account.viewFunction({
  contractId: "guestbook.near-examples.testnet",
  methodName: "get_messages",
  args: {},
})
</code></pre>
<p><strong>near-kit:</strong></p>
<pre><code class="language-typescript">const response = await near.view(
  "guestbook.near-examples.testnet",
  "get_messages",
  {}
)
</code></pre>
<h3 id="sending-near"><a class="header" href="#sending-near">Sending NEAR</a></h3>
<p><strong>near-api-js:</strong></p>
<pre><code class="language-typescript">const { utils } = require("near-api-js")

await account.sendMoney(
  "bob.testnet",
  utils.format.parseNearAmount("10.5") // Manual unit conversion
)
</code></pre>
<p><strong>near-kit:</strong></p>
<pre><code class="language-typescript">await near
  .transaction("alice.testnet")
  .transfer("bob.testnet", "10.5 NEAR") // Human-readable units
  .send()
</code></pre>
<h3 id="calling-a-contract-method"><a class="header" href="#calling-a-contract-method">Calling a Contract Method</a></h3>
<p><strong>near-api-js:</strong></p>
<pre><code class="language-typescript">await account.functionCall({
  contractId: "market.near",
  methodName: "buy_nft",
  args: { token_id: "token-1" },
  gas: "50000000000000", // Manual gas calculation
  attachedDeposit: utils.format.parseNearAmount("10"),
})
</code></pre>
<p><strong>near-kit:</strong></p>
<pre><code class="language-typescript">await near
  .transaction("alice.testnet")
  .functionCall(
    "market.near",
    "buy_nft",
    { token_id: "token-1" },
    { gas: "50 Tgas", attachedDeposit: "10 NEAR" } // Human-readable units
  )
  .send()
</code></pre>
<h3 id="multi-action-transactions"><a class="header" href="#multi-action-transactions">Multi-Action Transactions</a></h3>
<p><strong>near-api-js:</strong></p>
<pre><code class="language-typescript">const { transactions } = require("near-api-js")

await account.signAndSendTransaction({
  receiverId: "new-account.near",
  actions: [
    transactions.createAccount(),
    transactions.transfer(utils.format.parseNearAmount("5")),
    transactions.deployContract(contractWasm),
  ],
})
</code></pre>
<p><strong>near-kit:</strong></p>
<pre><code class="language-typescript">await near
  .transaction("alice.testnet")
  .createAccount("new-account.near")
  .transfer("new-account.near", "5 NEAR")
  .deployContract("new-account.near", contractWasm)
  .send()
</code></pre>
<p>The <code>near-kit</code> approach is more readable, less error-prone due to human-readable units, and uses a fluent API that is easier to compose.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
